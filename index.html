<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>ricky herrera</title>
  <!-- https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Animating_objects_with_WebGL -->

  <link rel="stylesheet" href="webgl.css" type="text/css">
  <script src="sylvester.js" type="text/javascript"></script>
  <script src="glUtils.js" type="text/javascript"></script>
  <script src="webgl-demo.js" type="text/javascript"></script>

  <!-- Fragment shader program -->

  <script id="shader-fs" type="x-shader/x-fragment">
    varying lowp vec4 vColor; void main(void) { gl_FragColor = vColor; }
  </script>

  <!-- Vertex shader program -->

  <script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition; attribute vec4 aVertexColor; uniform mat4 uMVMatrix; uniform mat4 uPMatrix; varying lowp
    vec4 vColor; void main(void) { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vColor = aVertexColor;
    }
  </script>

</head>

<link href="v3.css" rel="stylesheet">



<body onload="start();">

  <div id="mainBody">
    <div id="col1" style="float:left; margin:0; width:240px; padding-top:10%;">
      <mainHead>

        Ricky Herrera
      </mainHead>

      <div style="background-color: #ffffff; margin: 0 ;width: 250px;height: 1px">
      </div>

      <script type="text/javascript" src="v3.js">

      </script>


      <div class="tab" >
        <button class="tablinks" onclick="openC(event, 'about')" id="defaultOpen">about</button>
        <script>
          document.getElementById("defaultOpen").click();
        </script>
        <button class="tablinks" onclick="openC(event, 'blog')">blog</button>
        <button class="tablinks" onclick="openC(event, 'projects')">projects</button>
        <button class="tablinks" onclick="openC(event, 'films')">films</button>
        <button class="tablinks" onclick="openC(event, 'notes')">notes</button>
      </div>
      <div style="background-color: #e81f55; margin: 0 ;width: 239px;height: 1px;">
      </div>

      <div id="col1">
                <div id="aboot" class="tabcontent" style="text-align:justify; width: 235px;margin:0px ;padding-top: 40px;">
                  Technically, it's Ricardo, but its <i>whutever</i>. I'm a student at UC Berkeley studying Computer Science and
                  Film Studies. I have a deep passion for computer graphics, movies, and art. <br>
                </div>

                  <div id="projz" class="tabcontent" style="width: 250px;margin:0px ;padding-top: 20px;">
                
                          <img src="p0.png" width="200">
                  
                  </div>
<<<<<<< HEAD
          <div id="filmz" class="tabcontent" style="width: 250px;margin:0px ;padding-top: 40px;">
              <center>
                  <img src="filmz.png" width="200">
              </center>
          </div>
=======

                  <div id="filmz" class="tabcontent" style="width: 250px;margin:0px ;padding-top: 40px;padding-left:25px;">
                    - Sweet Victory<br>
                    - Walden <br>
                    - Only Love <br>
                    - The Loop <br>

                      
                      </div>
>>>>>>> 9cfb84d22f88e4241d07e6f8f4b40fa15dd6311b
      </div>

    </div>

    <div id="col2" style="float:right; width:550px; ;padding-right: 2%;">

      <div id="about" class="tabcontent" style="padding-top:15%">
                <canvas id="glcanvas" width="540" height="304">
                  Your browser doesn't appear to support the <code>&lt;canvas&gt;</code> element.
                </canvas>
      </div>

      <div id="blog" class="tabcontent">
        <mainHead>BLOG</mainHead>

        <p>blog is not available at the moment, however here are some tweets.</p>
        <a class="twitter-timeline" data-lang="en" data-width="540" data-height="600" data-theme="dark" data-link-color="#E81f55"
          href="https://twitter.com/nutritiousbig">Tweets by nutritiousbig</a>
        <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
      </div>

      <div id="projects" class="tabcontent">
        <mainHead>PROJECTS</mainHead><br/>

        <img src="p1.png" style="width:100px;padding-right:2%;" align="left"><br />
        <a href="p1website/index.html">Rasterizer</a> - C++ implemented image rasterizer – performs supersampling, hierarchical
        transforms, and texture mapping with antialiasing on SVG files and converts to 2D image. <br/><br><br>
        
          <img src="icon_meshedit.png" style="width:100px;padding-right:2%;" align="left"><br />
          <a href="p2website/index.html">MeshEdit</a> - C++ implemented 3D model mesh application; load and edit basic COLLADA
          mesh files (used by many major modeling packages and real time graphics engines).<br/><br><br >
          
            <img src="icon_pathtracer.png" style="width:100px;padding-right:2%;" align="left"><br />
            <a href="p3website/index.html">PathTracer</a> - C++ implemented, based on Physically Based Rendering (Pharr &
            Humphries) <br/><br>

              
              
      </div>

      <div id="notes" class="tabcontent">
        <mainHead>
          NOTES</mainHead><br> Here are some notes I have done for UC Berkeley's CS184 Computer Graphics and Imaging course.
        (I am currently typing up some of the notes. these are really crude and do not have proper citation at the moment).
        <br>
        <div class="tabn">
                  <button class="notetab" onclick="openT(event, 'rastr')">Rasterization</button> (pdf version) <br>
                  <notesec>- Rasterization<br>
                    <notesec>- Transforms & Projection<br>
                      <notesec>- Texture Mapping<br>
                        <notesec>- Visibility, Shading, Overall Pipeline<br>
                  <button class="notetab" onclick="openT(event, 'geom')">Geometry for Graphics</button> <br>
                  <notesec>- Introduction to Geometry and Splines<br>
                    <notesec>- Bezier Curves and Surfaces<br>
                      <notesec>- Mesh Representation & Geometry <br>
                        <notesec>- Geometry Processing<br>
                  <button class="notetab" onclick="openT(event, 'light')">Lighting and Materials</button> (pdf version) <br>
                  <notesec>- Introduction to ray tracing<br>
                    <notesec>- Radiometry and Photometry<br>
                      <notesec>- Monte Carlo Integration <br>
                        <notesec>- Global Illumination<br>
                          <notesec>- Material Modeling <br>
                  <button class="notetab" onclick="openT(event, 'cam')">Camera and Lenses</button>
                  <br>
                  <br>
        </div>
      </div>
      <div id="light" class="tabcontent">
        <h1>3.1 – Introduction to Ray Tracing</h1>
Ray tracing is a technique for rendering images by following the path of a ray of light and simulating the effects of its interaction with objects in a 3D scene. The resulting rendered image is realistic, since it follows a physically based model in which light interacts with objects in the physical world. 
Consider a ray of light as a stream of photons. This ray propagates through space until it hits a surface, which interrupts the stream. The surface either absorbs, reflects, or refracts the ray. For our purposes, light travels in straight lines. Light rays do not interfere with each other if they do happen to cross. Light rays travel from light sources to the eye. 
<br>
<i>An early attempt at ray tracing was done by Arthur Appel in 1968 with ray casting. The main idea behind ray casting is that for each pixel, trace a ray from the eye (camera) through that pixel, and find the first object that intersects with that ray. The material properties of the intersected surface determine the effect of the light in the scene, and then determine the shading of this object.
</i><br>
Recursive ray tracing is also possible. A ray of light can affect more than one surface; it can bounce off or even go through other surfaces in a scene. The value of this solution is more apparent for surfaces such as metal or glass.  
A ray is defined by its origin position o, t time (with range [0, ), and a unit direction vector d. It follows that this is the ray equation (in parametric form): 
<br>
Thus, r is a function of a time t giving the point along a ray. In order for this ray to interact with a scene, this ray needs to hit faces of object. Each face can be represented by a plane, which in a 3D space is defined by a normal vector and a point on that plane. Consider the equation for a plane:
<br>
where p’ is any point on the plane and N is the normal vector. 
Now we can set up the intersection. 
<br>
<!--

Class Ray {
    vec3d o; // origin
    vec3d c: // direction

    Ray (vec3d origin, vec3d direction){
        o = origin, d = direction;
    }
};

int main() {
    cons int W = 500;
    cons int H = 500;

    for (int y = 0; y < H; y++){
        for (int x = 0; x < W; x++){
	      Ray ray( vec3d(x,y,0), vec3d(0,0,1));
	
    If ray intersects with object:
        Draw that pixel according to object surface
			
  }
    }
}-->
<h2>Accelerating Ray-Surface Intersection</h2><br>
Now that intersections are possible, there is a way to optimize the process. It would be naïve to run the algorithm #pixels x #objects times. One way to avoid this is to use bounding volumes which basically binds a complex object with a simple box volume. The object will be fully contained within this box volume, and it follows that if the ray does not hit this box volume, it will not hit our complex object. 
There are 6 potential sides that a ray could hit our box volume. 
<br>
<h1>3.2 - Radiometry and Photometry – The Physics of Light</h1>
<h2>3.2.0 – Overview</h2>
In order to achieve physically based rendering, we need to adopt a framework based in physical properties of light. Radiometry provides a measurement system and units for illumination. It allows for the measure of the spatial properties of light. It follows that this will allow us to perform light calculations in a physically correct manner. 
What is light? In the real world sense, light is created by a physical process that converts energy into photons. Each photon carries a small amount of energy. Over some time, light consumes some amount of energy, Joules. Some is turned into heat, some into photons. Exposure, is the enrgy of photons hitting an object (film, sensors, sunburn, solar panels, etc.). In computer graphics, we basically assume a “steady state” of flow, that is the rate of energy consumption is constant, so flux (powere) and energy are often interchangeable. 
<h2>3.2.1 – Foundations</h2>
<br>
Before being able to solve the rendering equation, a few foundational units and concepts shall be reviewed. A reader familiar with the material can skip this section. 
An angle of a circle is the ratio of the subtended arc length  to radius :
A solid angle  of a sphere is the ratio of the subtended area  to radius squared : 
<br>
A solid angle is a 2-dimensional angle in 3-dimesional space that a object subtends at a point. It is a measure of how large an object appears to an observer at that point. 
The unit we are most interested in solving the rendering equation are differential solid angles. 
<br>




The direction vector is .
To be isotropic is to have the have the physical property that has the same value when measured in different directions. So an Isotropic Point source is a point that emits light in all directions equally. 
<br>
<h2>3.2.1 – Irradiance and Radiance</h2>
<br>
Irradiance (illuminance) is the power per unit area incident on a surface point. 
<br>
Radiance is the fundamental field quantity that describes the distribution of light in an environment. Radiance is the quantity associated with a ray. Rendering is all about computing radiance. Radiance is invariant along a ray in a vacuum. 
<br>
<h2>3.2.1 – Irradiance and Radiance<h2>

<h1>3.3 - Monte Carlo Integration </h1><br>
Although the cursor will never fall off the left end, it will often wander off the right end of the string. In this case we think that the cursor scans a U, which of course may be overwritten immediately. This is how the string becomes longer-a necessary feature, if we wish our machines to perform general computation. The string never becomes shorter.
Since 8 is a completely specified function, and the cursor never falls off the left end, there is only one reason why the machine cannot continue: One of the three halting states h, "yes", and "no" has been reached. If this happens, we say that the machine has halted. Furthermore, if state "yes" has been reached, we say the machine accepts its input; if "no" has been reached, then it rejects its input. If a machine halts on input x, we can define the output of the machine M on x, denoted M(x). If M accepts or rejects x, then M(x) = "yes" or "no", respectively. Otherwise, if h was reached, then the output is the string of M at the time of halting. Since the computation has gone on for finitely many steps, the string consists of at>, followed by a finite stringy, whose last symbol is not aU, possibly followed by a string-of Us (y could be empty). We consider stringy to be the output of the computation, and write M(x) = y. Naturally, it is possible that M will never halt on input x. If this is the case we write M(x) =/.
<br>
<h1>3.4 - Global Illumination</h1><br>
It is amazing how little we need to have everything! Viewed as a programming language, the Turing machine has a single data structure, and rather primitive one at that: A string of symbols. The available operations allow the program to move a cursor left and right on the string, to write on the current position, and to branch depending on the value of the current symbol. All in all, it is an extremely weak and primitive language. And yet, we shall argue in this chap- ter, it is capable of expressing any algorithm, of simulating any programming language.
<br>
From this initial configuration the machine takes a step according to 8, changing its state, printing a symbol, and moving the cursor; then it takes another step, and another. Note that, by our requirement on 8(p, t>), the string will always start with at>, and thus the cursor will never "fall off" the left end of the string.
<br>
<h1>3.5 - Material Modeling</h1><br>
It is amazing how little we need to have everything! Viewed as a programming language, the Turing machine has a single data structure, and rather primitive one at that: A string of symbols. The available operations allow the program to move a cursor left and right on the string, to write on the current position, and to branch depending on the value of the current symbol. All in all, it is an extremely weak and primitive language. And yet, we shall argue in this chap- ter, it is capable of expressing any algorithm, of simulating any programming language.




      </div>

      <div id="films" class="tabcontent">
        <mainHead>
          FILMS</mainHead><br />
        <h2><i>Sweet Victory</i> (2016)</h2>
        <iframe width="540" height="304" src="https://www.youtube.com/embed/KFBjPTmTnWQ" frameborder="0" allowfullscreen></iframe><br>
        My first 3D animated short! My notable contribution to this masterpiece is Marshmallow (or as like my mom refers to it, "El
        Bombon"), which I modeled and animated. Learning Maya and other software was so rewarding, and this project helped me explore some of their capabilites. Fun fact: the chocolate fountain was for a time a bifrost simulation with very viscous chocolate. However, the renderfarm hates us and it didn't go as planned. This was made during my semester of UCBUGG, probably the best class I have taken while at Berkeley. 

        <br>
        <h2><i>Walden</i> (2016) </h2>
        <iframe width="540" height="304" src="https://www.youtube.com/embed/VXAhPhIJJVg" frameborder="0" allowfullscreen></iframe><br>
        The piece was my group's submission for Cal State Long Beach's 24 Hours Challenge; as the name implies this was made in under
        24 hours. The prompt was "make a 1 minute short that contains a physical or metaphorical wall". You learn a lot about your animation partners when trapped in a computer lab for 24 hours. We all left with a new connection with one another; and sleep deprivation. 
        <br>

          
        <h2><i>The Only Love a Mans Ever Known</i> (2017) <br /></h2>
          <iframe width="540" height="304" src="https://www.youtube.com/embed/0EiJ86TQ2_g" frameborder="0" allowfullscreen></iframe><br> 
          This project was made for UC Berkeley's Advanced Digital Animation course, CNM190 (Fall 2016 - Spring 2017). In essence, its a short about the pangs of alcoholism, but very layered, revealing new meanings with every view. I worked on the sound effects, lighting, modeling, and post-production for this short. Specifically, the lighting I am proud of is during the liquor store scene, as we experiemented with what felt like every possible variation. I am really proud of the music I wrote for this, especially when I found my peers humming the music at random times. It has won an award at the East
          LA film festival, and is being considered for other film festivals!<br >
          
          <h2><i>The Loop</i> (2017) <br /></h2>
          <iframe width="540" height="304" src="https://www.youtube.com/embed/gXxwrEiDg48g" frameborder="0" allowfullscreen></iframe><br> 
          This short was made for the Campus Movie Festival @ UC Berkeley. I worked on the music, some color grading, and story ideas. (I wrote the music in 30 minutes, while waiting to get medication).<br>

          <br>
          STAY TUNED // MORE TO COME // 
        
      </div>
    </div>



  </div>

  <script>
    document.getElementById("defaultOpen").click();
  </script>

</body>



</html>